Звісно, ось детальний опис проєкту для вашого "майбутнього я". Це допоможе згадати всі ідеї, архітектурні рішення та потенційні виклики, коли ви повернетеся до роботи.

---

### **Проєкт: "FoodLocator" (або "PriceBite", "MenuHunter")**

**Дата створення документа:** 24.07.2025

**Автор:** Я (з минулого)

**Привіт, майбутній я!**

Ти почав цей проєкт з ідеєю створити корисний інструмент для себе та інших. Це нагадування про те, що ти хотів зробити, як ти це бачив, і які технології обрав. Не відхиляйся від курсу без вагомої причини!

#### **1. Основна концепція та бачення**

**Проблема, яку вирішуємо:** Знайти певну страву (наприклад, піцу "Чотири сири" або том-ям) у закладах поблизу та порівняти ціни на неї. Також надати можливість просто знайти ресторани поруч і швидко оцінити їхній рівень цін.

**Бачення:** Простий, швидкий та інтуїтивно зрозумілий вебзастосунок, який показує на карті або у списку ресторани, дозволяє шукати страви та порівнювати ціни. Головний фокус — на **даних та геолокації**.

#### **2. Ключові функції (MVP - Minimum Viable Product)**

*   **Пошук на основі геолокації:**
    *   Автоматичне визначення місцезнаходження користувача (з його дозволу).
    *   Можливість вручну ввести адресу.
    *   Відображення ресторанів у заданому радіусі (наприклад, 1, 3, 5 км).

*   **Пошук по стравах:**
    *   Глобальний пошуковий рядок, де користувач вводить назву страви (напр., "борщ", "суші філадельфія").
    *   Система показує список ресторанів, де є ця страва, відсортований за ціною або відстанню.

*   **Сторінка ресторану:**
    *   Основна інформація: назва, адреса, телефон, години роботи, рейтинг (якщо буде).
    *   Повне меню з цінами, розбите на категорії (закуски, супи, десерти).
    *   Кнопка "Показати на карті".

*   **Порівняння:**
    *   Коли користувач шукає конкретну страву, результат має бути у вигляді зручної для порівняння таблиці: `[Назва ресторану] - [Ціна] - [Відстань]`.

#### **3. Технічна архітектура**

Ти вирішив робити **декапл (decoupled) архітектуру**, і це правильне рішення. Фронтенд і бекенд — це два окремі проєкти, що спілкуються через API.

**3.1. Бекенд (Backend)**

*   **Технологія:** **Python + FastAPI**.
*   **Чому FastAPI?**
    *   **Висока продуктивність:** Асинхронність (async/await) "з коробки" ідеально підходить для I/O-залежних задач (запити до БД, зовнішніх API).
    *   **Автоматична документація:** FastAPI генерує інтерактивну документацію (Swagger UI та ReDoc) на основі коду. Це НЕЙМОВІРНО зекономить твій час. Просто перейди на `/docs`, щоб тестувати ендпоїнти.
    *   **Валідація даних:** Використання `Pydantic` для моделей даних забезпечує надійну валідацію вхідних і вихідних даних. Менше помилок, чистіший код.

*   **База даних:** **PostgreSQL + PostGIS**.
    *   **Чому PostgreSQL?** Це надійна, потужна реляційна БД. Дані про ресторани, меню та страви мають чітку структуру, тому SQL підходить ідеально.
    *   **Чому PostGIS?** Це розширення для PostgreSQL, що додає підтримку географічних об'єктів та запитів. Ти зможеш ефективно шукати "всі ресторани в радіусі N кілометрів від точки (широта, довгота)". Це набагато ефективніше, ніж рахувати відстані вручну на рівні Python.
    *   **ORM:** **SQLAlchemy** з **AsyncPG** драйвером для асинхронної роботи. Або розглянь **SQLModel** (від автора FastAPI), який поєднує SQLAlchemy і Pydantic.

*   **Основні моделі даних (схеми Pydantic/SQLAlchemy):**
    ```python
    # models.py

    class Restaurant(Base):
        id: int
        name: str
        address: str
        phone: str | None
        latitude: float  # Широта
        longitude: float # Довгота
        # + поле для PostGIS (geography/geometry)

    class Dish(Base):
        id: int
        name: str
        description: str | None
        category: str # напр. "Піца", "Супи", "Салати"

    class MenuItem(Base):
        id: int
        restaurant_id: int # Foreign Key до Restaurant
        dish_id: int       # Foreign Key до Dish
        price: float
        last_updated: datetime
    ```

*   **Ключові API ендпоїнти:**
    *   `GET /restaurants/nearby?lat=...&lon=...&radius=...` — основна функція.
    *   `GET /restaurants/{restaurant_id}` — деталі про ресторан.
    *   `GET /restaurants/{restaurant_id}/menu` — меню ресторану.
    *   `GET /search/dishes?q=...&lat=...&lon=...` — пошук страви з сортуванням по відстані.
    *   `POST /admin/restaurants` (та інші CRUD операції для наповнення бази даних, захищені авторизацією).

**3.2. Фронтенд (Frontend)**

*   **Технологія:** будь-який сучасний JS-фреймворк (**React, Vue, Svelte**).
*   **Чому?** Вони дозволяють створювати динамічні, інтерактивні інтерфейси.
*   **Взаємодія з бекендом:** через `fetch` або `axios` до API ендпоїнтів, які ти створив на FastAPI.
*   **Карти:** **Leaflet.js** (проста і безкоштовна) або **Mapbox** (красивіша, але може бути платною).
*   **Геолокація:** Використовуй `navigator.geolocation` API браузера, щоб отримати координати користувача.

#### **4. Потенційні виклики та як їх вирішувати**

1.  **Наповнення та актуалізація даних (Найбільший виклик!)**
    *   **Проблема:** Де брати меню та ціни? Вони постійно змінюються.
    *   **Рішення на старті (MVP):** Ручне введення даних для 10-20 ресторанів у твоєму районі. Створи простий адмін-інтерфейс.
    *   **Майбутні рішення:**
        *   **Веб-скрапінг:** Написати парсери для популярних сервісів доставки (Glovo, Bolt Food) або сайтів ресторанів. **Увага:** це може бути крихким (сайти змінюються) і порушувати правила використання.
        *   **API партнерів:** Можливо, деякі сервіси мають публічне API.
        *   **Краудсорсинг:** Дозволити користувачам додавати/оновлювати ціни (з модерацією).

2.  **Точність геолокації:**
    *   **Проблема:** Адреси потрібно перетворити на точні координати (широту та довготу).
    *   **Рішення:** Процес **геокодингу**. Можна використовувати зовнішні сервіси, як-от Google Geocoding API, OpenStreetMap (Nominatim). Деякі з них мають обмеження на безкоштовні запити.

3.  **UI/UX:**
    *   **Проблема:** Як зробити порівняння цін зручним та не перевантаженим?
    *   **Рішення:** Прототипуй! Намалюй на папері або в Figma, як виглядатиме екран пошуку, сторінка ресторану, таблиця порівняння. Простота — твій найкращий друг.

#### **5. План дій (Roadmap)**

1.  **Крок 1: Сетап.** Створи репозиторій на GitHub. Налаштуй віртуальне середовище Python (`.venv`). Встанови FastAPI, Uvicorn, SQLAlchemy, Psycopg (asyncpg).
2.  **Крок 2: Бекенд (база).** Спроектуй моделі в SQLAlchemy/SQLModel. Налаштуй підключення до БД. Створи перші, найпростіші ендпоїнти (наприклад, додати ресторан і отримати список всіх ресторанів).
3.  **Крок 3: Фронтенд (база).** Створи проєкт на React/Vue. Зроби простий запит до свого API, щоб отримати список ресторанів і вивести його на сторінку. Переконайся, що зв'язок між фронтом і беком працює.
4.  **Крок 4: Основна фіча.** Реалізуй гео-пошук. На бекенді — ендпоїнт з PostGIS. На фронтенді — запит геолокації та відображення на карті Leaflet.
5.  **Крок 5: Розширення.** Додай пошук по стравах, сторінки ресторанів, меню.
6.  **Крок 6: Деплой.** Розгорни бекенд (напр., на Heroku, Render, DigitalOcean) і фронтенд (напр., на Netlify, Vercel).




Звісно. Ось детальний технічний план для розробки бекенду на FastAPI. Цей план структурований по модулях і охоплює моделі даних, API ендпоїнти та ключову бізнес-логіку.

---

### **Детальний План для Бекенду Проєкту "FoodLocator"**

Цей документ описує архітектуру та реалізацію серверної частини проєкту.

#### **1. Технологічний стек та інструменти**

*   **Мова:** Python 3.10+
*   **Фреймворк:** FastAPI
*   **База даних:** PostgreSQL з розширенням PostGIS для гео-запитів.
*   **ORM:** SQLAlchemy 2.0 (асинхронний підхід) з GeoAlchemy2 для підтримки типів PostGIS. Розглянути SQLModel для спрощення.
*   **Валідація даних:** Pydantic (вбудовано у FastAPI).
*   **Асинхронний драйвер для БД:** `asyncpg`.
*   **Автентифікація:** JWT (JSON Web Tokens) з `python-jose` та `passlib` для хешування паролів.
*   **Сервер:** Uvicorn.
*   **Міграції БД:** Alembic.

#### **2. Структура проєкту (пропонована)**

```
/foodlocator_backend
|
├── /app
│   ├── /api
│   │   ├── __init__.py
│   │   ├── endpoints
│   │   │   ├── __init__.py
│   │   │   ├── auth.py         # Реєстрація, логін
│   │   │   ├── users.py        # Керування користувачами (профіль)
│   │   │   ├── restaurants.py  # CRUD для ресторанів
│   │   │   └── search.py       # Основні пошукові ендпоїнти
│   │   └── deps.py             # Залежності (напр., get_current_user)
│   ├── /core
│   │   ├── __init__.py
│   │   ├── config.py           # Налаштування (змінні середовища)
│   │   └── security.py         # Хешування паролів, робота з JWT
│   ├── /db
│   │   ├── __init__.py
│   │   ├── base.py             # Базова модель SQLAlchemy, сесія
│   │   └── models
│   │       ├── __init__.py
│   │       ├── user.py
│   │       ├── restaurant.py
│   │       └── dish.py
│   ├── /schemas
│   │   ├── __init__.py
│   │   ├── user.py             # Pydantic схеми для User
│   │   ├── restaurant.py       # Pydantic схеми для Restaurant
│   │   ├── dish.py
│   │   └── token.py            # Схема для JWT токена
│   ├── __init__.py
│   └── main.py                 # Головний файл FastAPI
|
├── /alembic                  # Папка для міграцій Alembic
├── alembic.ini
├── requirements.txt
└── .env                      # Файл зі змінними середовища
```

---

### **3. Модуль: Користувачі та Автентифікація**

**Мета:** Забезпечити реєстрацію, вхід та безпечне керування профілями користувачів.

#### **3.1. Модель даних (`user.py`)**

```python
# db/models/user.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from sqlalchemy.sql import func
from app.db.base import Base

class User(Base):
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, index=True)
    is_active = Column(Boolean(), default=True)
    is_admin = Column(Boolean(), default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
```

#### **3.2. API Ендпоїнти (`auth.py`, `users.py`)**

1.  **Реєстрація нового користувача**
    *   **Ендпоїнт:** `POST /api/v1/auth/register`
    *   **Вхідні дані (схема Pydantic):** `email`, `password`, `full_name`.
    *   **Логіка:**
        *   Перевірити, чи не існує вже користувач з таким email.
        *   Захешувати пароль за допомогою `passlib`.
        *   Зберегти нового користувача в БД.
    *   **Відповідь:** Дані про створеного користувача (без пароля).

2.  **Вхід (отримання токена)**
    *   **Ендпоїнт:** `POST /api/v1/auth/login`
    *   **Вхідні дані:** `username` (email) та `password` (у форматі `OAuth2PasswordRequestForm`).
    *   **Логіка:**
        *   Знайти користувача за email.
        *   Перевірити пароль.
        *   Якщо все вірно, згенерувати `access_token` (JWT).
    *   **Відповідь:** `{ "access_token": "...", "token_type": "bearer" }`.

3.  **Отримання даних про поточного користувача**
    *   **Ендпоїнт:** `GET /api/v1/users/me`
    *   **Захист:** Потребує валідного JWT токена в заголовку `Authorization`.
    *   **Логіка:**
        *   Розшифрувати токен, отримати `user_id`.
        *   Дістати користувача з БД.
    *   **Відповідь:** Публічні дані користувача.

---

### **4. Модуль: Ресторани**

**Мета:** Зберігати інформацію про заклади, включаючи їхнє місцезнаходження.

#### **4.1. Модель даних (`restaurant.py`)**

```python
# db/models/restaurant.py
from sqlalchemy import Column, Integer, String, Text
from geoalchemy2 import Geography
from app.db.base import Base

class Restaurant(Base):
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True, nullable=False)
    address = Column(String, nullable=False)
    # Зберігаємо координати для гео-пошуку.
    # 'srid=4326' - стандартна система координат WGS 84 (широта/довгота).
    location = Column(Geography(geometry_type='POINT', srid=4326), nullable=False)
    description = Column(Text)
    phone_number = Column(String)
    website = Column(String)
```

#### **4.2. API Ендпоїнти (`restaurants.py`)**

1.  **Створення нового ресторану (Admin only)**
    *   **Ендпоїнт:** `POST /api/v1/restaurants`
    *   **Вхідні дані:** `name`, `address`, `description` і т.д.
    *   **Логіка:**
        *   Прийняти адресу у вигляді тексту.
        *   **Геокодування:** Використати зовнішній сервіс (напр., Nominatim, Google Geocoding API) для перетворення адреси на координати (широта, довгота).
        *   Зберегти координати у полі `location` у форматі `POINT(longitude latitude)`.
        *   Зберегти ресторан у БД.
    *   **Відповідь:** Дані про створений ресторан.

2.  **Отримання інформації про ресторан**
    *   **Ендпоїнт:** `GET /api/v1/restaurants/{restaurant_id}`
    *   **Відповідь:** Детальна інформація про ресторан.

---

### **5. Модуль: Страви та Меню**

**Мета:** Керувати каталогом страв та їхніми цінами в конкретних ресторанах.

#### **5.1. Моделі даних (`dish.py`)**

```python
# db/models/dish.py
from sqlalchemy import Column, Integer, String, Float, ForeignKey, DateTime
from sqlalchemy.sql import func
from app.db.base import Base

# Загальний каталог страв
class Dish(Base):
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True, nullable=False)
    category = Column(String, index=True) # "Піца", "Супи", "Напої"
    description = Column(String)

# Позиція в меню (зв'язок страви, ресторану та ціни)
class MenuItem(Base):
    id = Column(Integer, primary_key=True, index=True)
    price = Column(Float, nullable=False)
    restaurant_id = Column(Integer, ForeignKey("restaurant.id"))
    dish_id = Column(Integer, ForeignKey("dish.id"))
    last_updated = Column(DateTime(timezone=True), onupdate=func.now())
```

#### **5.2. API Ендпоїнти (`restaurants.py`)**

1.  **Отримання меню ресторану**
    *   **Ендпоїнт:** `GET /api/v1/restaurants/{restaurant_id}/menu`
    *   **Логіка:** Знайти всі `MenuItem`, пов'язані з `restaurant_id`, і зробити `JOIN` з таблицею `Dish` для отримання назв страв.
    *   **Відповідь:** Список об'єктів, де кожен містить назву страви, опис, категорію та ціну.

---

### **6. Модуль: Пошук (ключова функціональність)**

**Мета:** Реалізувати основні пошукові сценарії.

#### **6.1. API Ендпоїнти (`search.py`)**

1.  **Пошук ресторанів поруч**
    *   **Ендпоїнт:** `GET /api/v1/search/restaurants-nearby`
    *   **Параметри запиту:** `lat` (широта), `lon` (довгота), `radius` (радіус у метрах).
    *   **Логіка:**
        *   Створити `POINT` з `lat` та `lon`.
        *   Використати функцію PostGIS **`ST_DWithin`** для ефективного пошуку всіх ресторанів у межах заданого радіуса. Це набагато швидше, ніж ручний перебір та обчислення відстані.
        *   Приклад на SQLAlchemy: `query.filter(ST_DWithin(Restaurant.location, point, radius_meters))`
    *   **Відповідь:** Список ресторанів, відсортований за відстанню.

2.  **Пошук страви в закладах поруч**
    *   **Ендпоїнт:** `GET /api/v1/search/dishes`
    *   **Параметри запиту:** `q` (назва страви), `lat`, `lon`, `radius`, `sort_by` (`price` або `distance`).
    *   **Логіка (складний запит):**
        1.  Знайти всі `Dish`, де `name` містить текст `q` (використовуючи `ILIKE` для нечутливого до регістру пошуку).
        2.  Зробити `JOIN` знайдених страв з `MenuItem`, щоб отримати `price` та `restaurant_id`.
        3.  Зробити `JOIN` з `Restaurant`, щоб отримати дані ресторану, включаючи його `location`.
        4.  Відфільтрувати результати за допомогою `ST_DWithin` на основі `lat`, `lon`, `radius`.
        5.  **Обчислити відстань** за допомогою функції **`ST_Distance`** для кожного знайденого ресторану.
        6.  Відсортувати фінальний результат за ціною (`MenuItem.price`) або відстанню.
    *   **Відповідь:** Список результатів, кожен з яких містить: `dish_name`, `price`, `restaurant_name`, `restaurant_address`, `distance_meters`.

#### **7. План розробки (кроки)**

1.  **Крок 1 (Налаштування):** Створити структуру проєкту, налаштувати `.venv`, встановити залежності, налаштувати `Alembic` та `main.py` з FastAPI.
2.  **Крок 2 (Користувачі):** Реалізувати моделі, схеми та ендпоїнти для реєстрації та логіну. Налаштувати JWT.
3.  **Крок 3 (Ресторани):** Реалізувати CRUD для ресторанів. Інтегрувати геокодування при створенні.
4.  **Крок 4 (Меню):** Реалізувати моделі та ендпоїнти для страв і меню.
5.  **Крок 5 (Наповнення):** Створити адмін-команди або скрипти для початкового наповнення БД даними (2-3 ресторани з меню).
6.  **Крок 6 (Пошук):** Реалізувати ендпоїнти пошуку, приділяючи особливу увагу складним SQL-запитам з `JOIN` та функціями `PostGIS`.
7.  **Крок 7 (Тестування):** Написати інтеграційні тести (напр., за допомогою `pytest` та `HTTPX`) для всіх ключових ендпоїнтів.
8.  **Крок 8 (Деплой):** Підготувати Dockerfile та налаштувати CI/CD для розгортання.





Звісно, ось детальний покроковий план для розробки фронтенд-частини на React, яка буде взаємодіяти з вашим FastAPI бекендом.

---

### **Детальний План для Фронтенду Проєкту "FoodLocator" (React)**

Цей документ описує архітектуру, компоненти та логіку клієнтської частини застосунку.

#### **1. Технологічний стек та інструменти**

*   **Фреймворк:** **React 18+**
*   **Ініціалізація проєкту:** **Vite**. Це сучасний та надзвичайно швидкий інструмент для збірки, набагато швидший за Create React App.
*   **Мова:** **TypeScript**. Обов'язково! Це забезпечить типізацію для пропсів, стану та, що найважливіше, для даних, які приходять з API. Це ідеально поєднується з Pydantic схемами вашого FastAPI бекенду.
*   **Маршрутизація (Роутинг):** **React Router v6**. Стандарт для навігації в React-застосунках.
*   **Запити до API:** **Axios**. Потужна бібліотека для HTTP-запитів. Дозволяє легко створювати екземпляр з базовим URL та налаштовувати заголовки (наприклад, для JWT токенів).
*   **Керування станом (State Management):**
    *   **Локальний стан:** Хуки `useState`, `useReducer`.
    *   **Стан сервера (Server State):** **React Query (TanStack Query)**. Це **ключова** бібліотека для цього проєкту. Вона неймовірно спростить роботу з даними з бекенду: завантаження, кешування, оновлення в фоні, обробка станів завантаження та помилок. **Не пишіть логіку `fetch` вручну з `useEffect`**, використовуйте React Query.
    *   **Глобальний стан (Global State):** **Context API + `useReducer`** або **Zustand**. Для керування станом автентифікації користувача та, можливо, глобальними налаштуваннями (тема, мова). Zustand значно простіший за Redux.
*   **Карти:** **Leaflet** з обгорткою **React-Leaflet**. Це безкоштовне, гнучке та потужне рішення для інтерактивних карт.
*   **Стилізація:**
    *   **Варіант 1 (рекомендовано для швидкості):** Бібліотека компонентів **Material-UI (MUI)** або **Chakra UI**. Вони надають готові, красиві та доступні компоненти (кнопки, поля вводу, сітки), що значно прискорить розробку.
    *   **Варіант 2 (більше контролю):** **Tailwind CSS**. Утилітарний підхід, що дозволяє швидко створювати будь-який дизайн, не виходячи з HTML.
*   **Форми:** **React Hook Form**. Чудова бібліотека для роботи з формами, яка спрощує валідацію та керування станом полів.

#### **2. Структура проєкту**

```
/foodlocator-frontend
|
├── /public
├── /src
│   ├── /api              # Логіка для запитів до бекенду (налаштування Axios)
│   ├── /assets           # Зображення, іконки, шрифти
│   ├── /components       # Перевикористовувані UI-компоненти (Button, Card, Map)
│   ├── /features         # Логіка та компоненти для конкретних фіч (Auth, Search)
│   ├── /hooks            # Кастомні хуки (напр., useGeolocation)
│   ├── /lib              # Зовнішні сервіси, клієнти (axios, react-query)
│   ├── /pages            # Компоненти, що відповідають за окремі сторінки
│   ├── /store            # Глобальний стан (Zustand або Context)
│   ├── /types            # TypeScript типи та інтерфейси (особливо для API)
│   └── App.tsx           # Головний компонент з роутингом
│   └── main.tsx          # Вхідна точка застосунку
|
├── .env.local            # Змінні середовища
├── package.json
├── tsconfig.json
└── vite.config.ts
```

---

### **3. Розробка по модулях і компонентах**

#### **3.1. База та Налаштування**

1.  **Ініціалізація:** `npm create vite@latest foodlocator-frontend -- --template react-ts`
2.  **Налаштування API клієнта (`src/lib/axios.ts`):**
    *   Створити екземпляр Axios з `baseURL` з `.env` (`VITE_API_BASE_URL=http://localhost:8000/api/v1`).
    *   Налаштувати interceptors для автоматичного додавання JWT токена в заголовок `Authorization` для захищених запитів.
3.  **Налаштування React Query (`src/lib/react-query.ts`):**
    *   Створити `QueryClient`.
    *   Обгорнути `App` в `QueryClientProvider` у файлі `main.tsx`.
4.  **Налаштування роутингу (`App.tsx`):**
    *   Використовувати `createBrowserRouter` з React Router v6 для визначення всіх маршрутів застосунку (`/`, `/search`, `/restaurant/:id`, `/login` і т.д.).

#### **3.2. Компоненти (Pages & Reusable)**

1.  **Сторінки (`src/pages`):**
    *   `HomePage.tsx`: Головна сторінка з великим пошуковим рядком та, можливо, картою.
    *   `SearchResultsPage.tsx`: Відображає результати пошуку страв або ресторанів.
    *   `RestaurantDetailPage.tsx`: Детальна інформація про один ресторан, його меню та розташування на карті.
    *   `LoginPage.tsx` / `RegisterPage.tsx`: Форми для входу та реєстрації.
    *   `ProfilePage.tsx`: Сторінка профілю користувача (захищена).
    *   `NotFoundPage.tsx`: Сторінка 404.

2.  **Перевикористовувані компоненти (`src/components`):**
    *   `Layout.tsx`: Загальний макет з `Navbar` та `Footer`.
    *   `Navbar.tsx`: Навігаційна панель з логотипом, посиланням на головну та кнопками "Вхід"/"Профіль".
    *   `SearchBar.tsx`: Компонент для пошуку страв.
    *   `RestaurantCard.tsx`: Картка для відображення короткої інформації про ресторан у списку.
    *   `DishListItem.tsx`: Рядок у меню ресторану з назвою страви та ціною.
    *   `MapComponent.tsx`: **Ключовий компонент!**
        *   **Пропси:** `center` (координати), `zoom` (масштаб), `markers` (масив маркерів).
        *   **Логіка:** Використовує `react-leaflet` для відображення карти та маркерів. Клік по маркеру може відкривати `Popup` з інформацією або перенаправляти на сторінку ресторану.
    *   `LoadingSpinner.tsx` / `ErrorMessage.tsx`: Компоненти для відображення стану завантаження та помилок (дуже зручно використовувати з React Query).

#### **3.3. Реалізація ключових функцій**

1.  **Автентифікація (фіча `Auth`):**
    *   Створити сторінки `LoginPage` та `RegisterPage` з формами (використовувати `React Hook Form`).
    *   Створити хук `useAuth` (який використовує `Zustand` або `Context`), що надає: `user`, `token`, `login(data)`, `register(data)`, `logout()`.
    *   Функція `login` відправляє запит до `POST /auth/login`, у разі успіху зберігає токен в `localStorage` та в стані, а також додає його в заголовки Axios.
    *   Створити компонент `ProtectedRoute`, який перевіряє наявність токена і, якщо його немає, перенаправляє на `/login`.

2.  **Геолокація та головна сторінка:**
    *   Створити кастомний хук `useGeolocation()` (`src/hooks/useGeolocation.ts`). Він використовує `navigator.geolocation.getCurrentPosition`, повертає `coordinates`, `isLoading`, `error`.
    *   На `HomePage` викликати `useGeolocation()`.
    *   Поки координати завантажуються, показувати `LoadingSpinner`. Якщо є помилка — `ErrorMessage`.
    *   Отримані координати передати в `MapComponent` та в хук React Query для запиту ресторанів поруч (`GET /search/restaurants-nearby`).

3.  **Пошук страв:**
    *   `SearchBar` отримує текст від користувача.
    *   При сабміті форми відбувається перехід на сторінку `/search?q=...`.
    *   `SearchResultsPage` зчитує параметр `q` з URL, отримує координати (з `useGeolocation`) і викликає хук React Query для запиту на `GET /search/dishes`.
    *   React Query автоматично керуватиме завантаженням. Результати відображаються у вигляді списку.

#### **4. План розробки (Roadmap)**

1.  **Крок 1: Сетап (1-2 дні).**
    *   Ініціалізація проєкту з Vite+TS.
    *   Встановлення всіх залежностей (`axios`, `react-router-dom`, `react-query`, `leaflet`, `react-leaflet`, `zustand`).
    *   Налаштування базового роутингу та структури папок.

2.  **Крок 2: Автентифікація (2-3 дні).**
    *   Створення сторінок `Login`, `Register`.
    *   Налаштування `useAuth` хука/стора.
    *   Підключення до API ендпоїнтів `/auth/login`, `/auth/register`.
    *   Реалізація `ProtectedRoute`.

3.  **Крок 3: Ядро - Карта та геолокація (2-3 дні).**
    *   Створення хука `useGeolocation`.
    *   Створення та налаштування `MapComponent` з `react-leaflet`.
    *   Реалізація запиту на `GET /search/restaurants-nearby` за допомогою React Query.
    *   Відображення ресторанів на карті на `HomePage`.

4.  **Крок 4: Пошук та результати (2 дні).**
    *   Створення `SearchBar` та `SearchResultsPage`.
    *   Реалізація логіки пошуку страв (`GET /search/dishes`).
    *   Відображення результатів у вигляді списку.

5.  **Крок 5: Деталізація (1-2 дні).**
    *   Створення `RestaurantDetailPage`.
    *   Реалізація запитів для отримання деталей про ресторан та його меню.
    *   Відображення інформації.

6.  **Крок 6: Стилізація та UI/UX (постійно).**
    *   Поступове покращення зовнішнього вигляду за допомогою обраної бібліотеки стилів.
    *   Додавання анімацій, `LoadingSpinner`, обробка всіх станів помилок.

**Порада для тебе з майбутнього:** Завжди думай про стани! Для кожного запиту до API є щонайменше три стани: `loading`, `success`, `error`. React Query допоможе тобі керувати ними декларативно. Не ігноруй їх